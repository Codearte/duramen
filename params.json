{"name":"Duramen","tagline":"Java Persistent Event Bus","body":"Duramen\r\n=======\r\n\r\nPersistent event bus implementation for Java. Easily integrates with Spring Framework. By default uses file backed database. Guarantees that event will be dispatched.\r\n\r\n##Usage:\r\n\r\n1) Add duramen dependency:\r\n  eu.codearte.duramen:duramen:0.9.0\r\n2) Use ```@EnableDuramen``` annotation to import Duramen into your project:\r\n```java\r\n@Configuration\r\n@ComponentScan\r\n@EnableDuramen\r\npublic class FooConfiguration {\r\n \r\n}\r\n```\r\n\r\n3) Implement custom event class:\r\n```java\r\npublic class FooEvent extends Event {\r\n\tprivate String message;\r\n \r\n\t// getters and setters\r\n}\r\n```\r\n\r\n4) To produce events you have to implement producer component:\r\n```java\r\nimport eu.codearte.duramen.EventBus;\r\n \r\n@Component\r\npublic class FooEventProducer {\r\n\r\n\tprivate final EventBus eventBus;\r\n  \r\n\t@Autowired\r\n\tpublic FooEventProducer(EventBus eventBus) {\r\n\t\tthis.eventBus = eventBus;\r\n\t}\r\n\r\n\t/** \r\n\t * This method will be called from your production code\r\n\t*/\r\n\tpublic void produce() {\r\n\t\tFooEvent event = new FooEvent();\r\n\t\tevent.setMessage(\"Test message\");\r\n\t\teventBus.publish(event);\r\n\t}\r\n}\r\n```\r\n\r\n5) To receive events you have to implement consumer. Generic type in ```EventHandler``` will decide which events will be processed in particular consumer:\r\n```java\r\nimport eu.codearte.duramen.handler.EventHandler;\r\n\r\n@Component\r\npublic class FooEventConsumer implements EventHandler<FooEvent> {\r\n\r\n\t@Override\r\n\tpublic void onEvent(FooEvent event) {\r\n\t\tSystem.out.println(\"Received message: \" + event.getMessage());\r\n\t}\r\n\r\n}\r\n```\r\n\r\n##Testing:\r\n\r\nUsually in test scope we don't want to persist our events. To achieve such behaviour we can configure custom bean:\r\n```java\r\nimport eu.codearte.duramen.datastore.InMemory();\r\n \r\n@Bean\r\npublic Datastore inMemoryDatastore() {\r\n\treturn new InMemory();\r\n}\r\n```\r\n\r\n##Error handling:\r\n\r\nWhen ```EventHandler``` processing bean throws an exception, it will be logged with event data serialized to JSON.\r\n\r\nYou can specify custom ```ExceptionHandler``` by creating bean implementing ```eu.codearte.duramen.handler.ExceptionHandler``` interface.\r\n\r\n##Available datastores\r\n\r\nIn Duramen there are 3 ```Datastore``` objects.\r\n\r\n###FileData\r\n\r\nDefault implementation. Backed by [HugeCollections](https://github.com/OpenHFT/HugeCollections) SharedHashMap. It stores events in binary file (by default duramen.data).\r\nTo use this implementation you don't have to do anything, as long as you accept default values (see \"Specifying messages limits\").\r\nTo change defaults you need create own bean:\r\n\r\n```java\r\nimport eu.codearte.duramen.datastore.FileData;\r\n \r\n@Bean\r\npublic Datastore fileDatastore() {\r\n\treturn new FileData(\"/tmp/myfile.data\", /*entries*/ 10, /*entrySize*/, 8192);\r\n}\r\n```\r\n\r\n###Embedded H2\r\n\r\nYou can also use embedded H2 database.\r\n\r\n```java\r\nimport eu.codearte.duramen.datastore.EmbeddedH2;\r\n\r\n@Bean\r\npublic Datastore embeddedH2Datastore() {\r\n\treturn EmbeddedH2();\r\n}\r\n \r\n// or\r\n\r\n@Bean\r\npublic Datastore embeddedH2Datastore() {\r\n\treturn EmbeddedH2(\"jdbc:h2:file:/tmp/duramen.data\");\r\n}\r\n```\r\n\r\n###Relational DB\r\n\r\nIf you want to use your own relational database as a ```Datastore``` it is of course possible. \r\nYou just need to create class extending ```eu.codearte.duramen.datastore.RelationalDB```\r\n\r\n###In memory\r\n\r\nWe've already described ```InMemory``` datastore in \"Testing\" section\r\n\r\n##Customizing default configuration:\r\n\r\nAs you can see to use Duramen no configuration is required. However if you want, there are some options to customize.\r\n\r\n###Specifying messages limits:\r\n\r\nBy default message size is set to 4096 bytes. You can change this value by defining bean:\r\n\r\n```java\r\n@Bean\r\npublic Integer maxMessageSize() {\r\n\treturn 8192;\r\n}\r\n```\r\n\r\nMessage count limit is set to 1024 events in queue. You can change this value by defining bean:\r\n\r\n```java\r\n@Bean\r\npublic Integer maxMessageCount() {\r\n\treturn 2048;\r\n}\r\n```\r\n\r\n###Processing options\r\n\r\nBy default Duramen uses daemon threads, but it can be easily changes by declaring:\r\n\r\n```java\r\n@Bean\r\npublic Boolean useDaemonThreads() {\r\n\treturn false;\r\n}\r\n```\r\n\r\nAlso number of threads processing events (default we use only one thread) can be increased:\r\n\r\n```java\r\n@Bean\r\npublic Integer maxProcessingThreads() {\r\n\treturn 2;\r\n}\r\n```\r\n\r\nFinally, if you want, there is a possibility to use own ExecutorService for processing events.\r\n```java\r\n@Bean\r\n\tpublic ExecutorService duramenExecutorService() {\r\n\treturn Executors.newCachedThreadPool();\r\n}\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}