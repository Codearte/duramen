{"name":"Duramen","tagline":"Java Persistent Event Bus","body":"Duramen\r\n=======\r\n\r\nPersistent event bus implementation for Java. Easily integrates with Spring Framework. By default uses file backed embedded H2 database. Guarantees that event will be dispatched.\r\n\r\n##Usage:\r\n\r\n1. Add duramen dependency:\r\n  eu.codearte.duramen:duramen:0.7.0\r\n2. Use ```@EnableDuramen``` annotation to import Duramen into your project:\r\n ```java\r\n @Configuration\r\n @ComponentScan\r\n @EnableDuramen\r\n public class FooConfiguration {\r\n \r\n }\r\n```\r\n3. Implement custom event class:\r\n ```java\r\n public class FooEvent extends Event {\r\n    private String message;\r\n \r\n    // getters and setters\r\n }\r\n```\r\n4. To produce events you have to implement producer component:\r\n ```java\r\n import eu.codearte.duramen.EventBus;\r\n \r\n @Component\r\n public class FooEventProducer {\r\n \r\n    private final EventBus eventBus;\r\n   \r\n    @Autowired\r\n    public FooEventProducer(EventBus eventBus) {\r\n\t    this.eventBus = eventBus;\r\n    }\r\n\r\n    /** \r\n     * This method will be called from your production code\r\n     */\r\n    public void produce() {\r\n\t    FooEvent event = new FooEvent();\r\n\t    event.setMessage(\"Test message\");\r\n\t    eventBus.publish(event);\r\n \t  }\r\n }\r\n```\r\n5. To receive events you have to implement consumer. Generic type in ```EventHandler``` will decide which events will be processed in particular consumer:\r\n ```java\r\n import eu.codearte.duramen.handler.EventHandler;\r\n\r\n @Component\r\n public class FooEventConsumer implements EventHandler<FooEvent> {\r\n\r\n \t @Override\r\n\t public void onEvent(FooEvent event) {\r\n\t   System.out.println(\"Received message: \" + event.getMessage());\r\n\t }\r\n\r\n }\r\n```\r\n\r\n##Testing:\r\n\r\nUsually in test scope we don't want to persist our events. To achieve such behaviour we can configure custom bean:\r\n```java\r\n import eu.codearte.duramen.datastore.InMemory();\r\n \r\n @Bean\r\n public Datastore inMemoryDatastore() {\r\n\t return new InMemory();\r\n }\r\n```\r\n\r\n##Error handling:\r\n\r\nWhen ```EventHandler``` processing bean throws an exception, it will be logged with event data serialized to JSON.\r\n\r\n##Available datastores\r\n\r\nIn Duramen there are 3 ```Datastore``` objects.\r\n\r\n###FileData\r\n\r\nDefault implementation. Backed by [HugeCollections](https://github.com/OpenHFT/HugeCollections) SharedHashMap. It stores events in binary file (by default duramen.data).\r\nTo use this implementation you don't have to do anything, as long as you accept default values (max 1000 concurrent entries each 4096 bytes).\r\nTo change defaults you need create own bean:\r\n\r\n```java\r\n import eu.codearte.duramen.datastore.FileData;\r\n \r\n @Bean\r\n public Datastore fileDatastore() {\r\n   return new FileData(\"/tmp/myfile.data\");\r\n }\r\n \r\n // or\r\n \r\n  @Bean\r\n  public Datastore fileDatastore() {\r\n    return new FileData(\"/tmp/myfile.data\", /*entries*/ 10, /*entrySize*/, 8192);\r\n  }\r\n```\r\n\r\n###Embedded H2\r\n\r\nYou can also use embedded H2 database.\r\n\r\n```java\r\n import eu.codearte.duramen.datastore.EmbeddedH2;\r\n \r\n @Bean\r\n public Datastore embeddedH2Datastore() {\r\n   return EmbeddedH2();\r\n }\r\n \r\n // or\r\n\r\n  @Bean\r\n  public Datastore embeddedH2Datastore() {\r\n    return EmbeddedH2(\"jdbc:h2:file:/tmp/duramen.data\");\r\n  }\r\n```\r\n\r\n###In memory\r\n\r\nWe've already described ```InMemory``` datastore in \"Testing\" section\r\n\r\n##Customizing default configuration:\r\n\r\nAs you can see to use Duramen no configuration is required. However if you want, there are some options to customize.\r\n\r\n###Specifying message size:\r\n\r\nBy default message size is set to 4096 bytes. You can change this value by defining bean:\r\n\r\n```java\r\n\t@Bean\r\n  public Integer maxMessageSize() {\r\n  \treturn 8192;\r\n  }\r\n```\r\n\r\n###Processing options\r\n\r\nBy default Duramen uses daemon threads, but it can be easily changes by declaring:\r\n\r\n```java\r\n\t@Bean\r\n\tpublic Boolean useDaemonThreads() {\r\n\t\treturn false;\r\n\t}\r\n```\r\n\r\nAlso number of threads processing events (default we use only one thread) can be increased:\r\n\r\n```java\r\n\t@Bean\r\n\tpublic Integer maxProcessingThreads() {\r\n\t\treturn 2;\r\n\t}\r\n```\r\n\r\nFinally, if you want, there is a possibility to use own ExecutorService for processing events.\r\n```java\r\n\t@Bean\r\n \tpublic ExecutorService duramenExecutorService() {\r\n \t\treturn Executors.newCachedThreadPool();\r\n \t}\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}